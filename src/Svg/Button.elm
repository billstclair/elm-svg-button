----------------------------------------------------------------------
--
-- Button.elm
-- SVG Buttons
-- Copyright (c) 2018-2019 Bill St. Clair <billstclair@gmail.com>
-- Some rights reserved.
-- Distributed under the MIT License
-- See LICENSE.txt
--
----------------------------------------------------------------------


module Svg.Button exposing
    ( Button, Content(..), Location, Size, Msg, RepeatTime(..), Colors
    , simpleButton, repeatingButton
    , update, checkSubscription
    , TriangularButtonDirection(..), setTriangularButtonRenderers
    , getState, setState, isTouchAware, setTouchAware, getSize, setSize
    , getColors, setColors
    , getRenderBorder, setRenderBorder
    , getRenderContent, setRenderContent
    , getRenderOverlay, setRenderOverlay
    , normalRepeatTime, defaultColors
    , render, renderBorder, renderContent, renderOverlay
    , renderTriangularBorder, renderTriangularOverlay
    , triangularButtonCorners, triangularButtonPathString
    )

{-| The `Svg.Button` module makes it easy to create SVG buttons.

Currently, the buttons are rectangular, with a two-pixel wide black border, containing either text or Svg you provide for their body. They support single clicks or repeated clicks, and work on both regular computer browsers, with a mouse, or portable browsers, with a touch screen.


# Types

@docs Button, Content, Location, Size, Msg, RepeatTime, Colors


# Constructors

@docs simpleButton, repeatingButton


# Events

@docs update, checkSubscription


# Triangular Buttons

@docs TriangularButtonDirection, setTriangularButtonRenderers


# Button state accessors

@docs getState, setState, isTouchAware, setTouchAware, getSize, setSize
@docs getColors, setColors
@docs getRenderBorder, setRenderBorder
@docs getRenderContent, setRenderContent
@docs getRenderOverlay, setRenderOverlay


# Constants

@docs normalRepeatTime, defaultColors


# Rendering

@docs render, renderBorder, renderContent, renderOverlay
@docs renderTriangularBorder, renderTriangularOverlay


# Triangular Button Corners

@docs triangularButtonCorners, triangularButtonPathString

-}

import Debug exposing (log)
import Html
import Html.Events exposing (on)
import Json.Decode as JD exposing (field, float, map2)
import Svg exposing (Attribute, Svg, g, rect, text, text_)
import Svg.Attributes as Svga
    exposing
        ( dominantBaseline
        , fill
        , fillOpacity
        , fontSize
        , height
        , opacity
        , pointerEvents
        , stroke
        , strokeOpacity
        , strokeWidth
        , style
        , textAnchor
        , transform
        , width
        , x
        , y
        )
import Svg.Events exposing (onMouseDown, onMouseOut, onMouseOver, onMouseUp)
import Task
import Time exposing (Posix)


{-| Opaque internal message.

You wrap these with the `(Msg -> msg)` you pass to `render`, and pass them to `update`.

-}
type Msg
    = MouseDown
    | MouseOut
    | MouseUp
    | TouchStart
    | TouchEnd
    | Repeat
    | Subscribe Float


{-| Read a button's `state`.
-}
getState : Button state msg -> state
getState (Button button) =
    button.state


{-| Set a button's `state`.
-}
setState : state -> Button state msg -> Button state msg
setState state (Button button) =
    Button
        { button | state = state }


{-| Read a button's size.
-}
getSize : Button state msg -> Size
getSize (Button button) =
    button.size


{-| Set a button's size.
-}
setSize : Size -> Button state msg -> Button state msg
setSize size (Button button) =
    Button
        { button | size = size }


{-| Return True if a Button is touch aware.
-}
isTouchAware : Button state msg -> Bool
isTouchAware (Button button) =
    button.touchAware


{-| Set whether a button is touch aware.

`update` notices when it gets a touch event, and sets the `touchAware` state, but since you usually don't save updated simple buttons, the next event won't notice. Mobile browsers have a delay in generating a simulated click event. Knowing that the button is touch aware eliminates that delay, since the click is then generated by the `TouchEnd` event instead of the `MouseUp` event.

-}
setTouchAware : Bool -> Button state msg -> Button state msg
setTouchAware touchAware (Button button) =
    Button
        { button | touchAware = touchAware }


{-| Three ways to draw the button content.

`TextContent` encapsulates a `String`, which is sized to half the button height and centered.

`SvgContent` allows you to render any `Svg` you wish.

`NoContent` renders nothing.

-}
type Content msg
    = TextContent String
    | SvgContent (Svg msg)
    | NoContent


{-| A two-dimensional location: (x, y)
-}
type alias Location =
    ( Float, Float )


{-| A two-dimensional size: (width, height)
-}
type alias Size =
    ( Float, Float )


{-| The Colors for a button.
-}
type alias Colors =
    { background : String
    , outline : String
    , text : String
    }


{-| The defaut colors.
-}
defaultColors : Colors
defaultColors =
    { background = "white"
    , outline = "black"
    , text = "black"
    }


{-| An Svg Button.

Create one with `simpleButton` or `repeatingButton`.

-}
type Button state msg
    = Button
        { size : Size
        , repeatTime : RepeatTime
        , delay : Float
        , enabled : Bool
        , state : state
        , touchAware : Bool
        , colors : Colors
        , renderBorder : Button state msg -> Svg msg
        , renderContent : Content msg -> Button state msg -> Svg msg
        , renderOverlay : (Msg -> msg) -> Button state msg -> Svg msg
        }


{-| Create a simple, rectanglar button.

It sends a `msg` when clicked or tapped.

The `view` function draws a two-pixel wide, black border around it. Your drawing function should leave room for that, or it will be overlaid.

-}
simpleButton : Size -> state -> Button state msg
simpleButton =
    repeatingButton NoRepeat


{-| First arg to `repeatingButton`.

The two `Float` args to `RepeatTimeWithInitialDelay` are the initial delay and the subsequent repeat period, in milliseconds.

-}
type RepeatTime
    = NoRepeat
    | RepeatTime Float
    | RepeatTimeWithInitialDelay Float Float


{-| Like `simpleButton`, but repeats the click or tap periodically, as long as the mouse or finger is held down.
-}
repeatingButton : RepeatTime -> Size -> state -> Button state msg
repeatingButton repeatTime size state =
    Button
        { size = size
        , repeatTime = repeatTime
        , delay = 0
        , enabled = True
        , state = state
        , touchAware = False
        , colors = defaultColors
        , renderBorder = renderBorder
        , renderContent = renderContent
        , renderOverlay = renderOverlay
        }


{-| Change the colors of a button.
-}
setColors : Colors -> Button state msg -> Button state msg
setColors colors (Button button) =
    Button { button | colors = colors }


{-| Get the colors of a button.
-}
getColors : Button state msg -> Colors
getColors (Button button) =
    button.colors


{-| Get a button's border renderer.
-}
getRenderBorder : Button state msg -> (Button state msg -> Svg msg)
getRenderBorder (Button button) =
    button.renderBorder


{-| Replace a button's default `renderButton` function with your own.
-}
setRenderBorder : (Button state msg -> Svg msg) -> Button state msg -> Button state msg
setRenderBorder renderer (Button button) =
    Button { button | renderBorder = renderer }


{-| Get a button's content renderer.
-}
getRenderContent : Button state msg -> (Content msg -> Button state msg -> Svg msg)
getRenderContent (Button button) =
    button.renderContent


{-| Replace a button's default `renderContent` function with your own.
-}
setRenderContent : (Content msg -> Button state msg -> Svg msg) -> Button state msg -> Button state msg
setRenderContent renderer (Button button) =
    Button { button | renderContent = renderer }


{-| Get a button's content renderer.
-}
getRenderOverlay : Button state msg -> ((Msg -> msg) -> Button state msg -> Svg msg)
getRenderOverlay (Button button) =
    button.renderOverlay


{-| Replace a button's default `renderOverlay` function with your own.
-}
setRenderOverlay : ((Msg -> msg) -> Button state msg -> Svg msg) -> Button state msg -> Button state msg
setRenderOverlay renderer (Button button) =
    Button { button | renderOverlay = renderer }


repeatDelays : RepeatTime -> ( Float, Float )
repeatDelays repeatTime =
    case repeatTime of
        NoRepeat ->
            ( 0, 0 )

        RepeatTime delay ->
            ( delay, delay )

        RepeatTimeWithInitialDelay delay nextDelay ->
            ( delay, nextDelay )


{-| This is the usual value used for the repeat time of a repeating button.

It has an initial delay of 1/2 second and a repeat period of 1/10 second.

-}
normalRepeatTime : RepeatTime
normalRepeatTime =
    RepeatTimeWithInitialDelay 500 100


{-| Call this to process a Button message from inside your wrapper.

The `Bool` in the return value is true if this message should be interpreted as a click on the button. Simple buttons never change the button or return a command you need to care about, but you'll need to call `getState` on the button to figure out what to do (unless your application has only a single button).

-}
update : (Msg -> msg) -> Msg -> Button state msg -> ( Bool, Button state msg, Cmd msg )
update wrapper msg button =
    case msg of
        Subscribe _ ->
            ( False, button, Cmd.none )

        TouchStart ->
            case button of
                Button but ->
                    let
                        ( initialDelay, delay ) =
                            repeatDelays but.repeatTime

                        button2 =
                            Button
                                { but
                                    | touchAware = True
                                    , enabled = True
                                    , delay = delay
                                }
                    in
                    ( initialDelay > 0
                    , button2
                    , repeatCmd initialDelay wrapper
                    )

        MouseDown ->
            case button of
                Button but ->
                    let
                        ( initialDelay, delay ) =
                            repeatDelays but.repeatTime

                        button2 =
                            Button
                                { but
                                    | enabled = True
                                    , delay = delay
                                }
                    in
                    ( initialDelay > 0 && not but.touchAware
                    , button2
                    , repeatCmd initialDelay wrapper
                    )

        MouseOut ->
            case button of
                Button but ->
                    let
                        button2 =
                            Button
                                { but
                                    | enabled = False
                                    , delay = 0
                                }
                    in
                    ( False
                    , button2
                    , if but.enabled then
                        repeatCmd 0 wrapper

                      else
                        Cmd.none
                    )

        TouchEnd ->
            case button of
                Button but ->
                    let
                        button2 =
                            Button
                                { but
                                    | enabled = False
                                    , delay = 0
                                }
                    in
                    ( but.enabled && but.touchAware && but.delay <= 0
                    , button2
                    , repeatCmd 0 wrapper
                    )

        MouseUp ->
            case button of
                Button but ->
                    let
                        button2 =
                            Button
                                { but
                                    | enabled = False
                                    , delay = 0
                                }
                    in
                    ( but.enabled && not but.touchAware && but.delay <= 0
                    , button2
                    , repeatCmd 0 wrapper
                    )

        Repeat ->
            case button of
                Button but ->
                    let
                        delay =
                            if but.enabled then
                                but.delay

                            else
                                0
                    in
                    ( but.enabled
                    , Button { but | delay = delay }
                    , repeatCmd but.delay wrapper
                    )


repeatCmd : Float -> (Msg -> msg) -> Cmd msg
repeatCmd delay wrapper =
    let
        task =
            Task.succeed (Subscribe delay)
    in
    Task.perform wrapper task


{-| Subscriptions are one type of message you can get inside your wrapper.

In order to check if a message is a subscription, call `checkSubscription`. If it returns a time delay and Button message, you need to use that to create a time subscription for your application.

Simple buttons don't need subscriptions. Only repeating buttons use them.

-}
checkSubscription : Msg -> Button state msg -> Maybe ( Float, Msg )
checkSubscription msg button =
    case msg of
        Subscribe delay ->
            Just ( delay, Repeat )

        _ ->
            Nothing


{-| Render a button's outline, your content, and the mouse-sensitive overlay.

Does this by sizing an SVG `g` element at the `Location` you pass and the size of the `Button`, and calling `renderBorder`, `renderContent`, and `renderOverlay` inside it.

-}
render : Location -> Content msg -> (Msg -> msg) -> Button state msg -> Svg msg
render ( xf, yf ) content wrapper button =
    case button of
        Button but ->
            let
                ( xs, ys ) =
                    ( String.fromFloat xf, String.fromFloat yf )

                ( wf, hf ) =
                    but.size

                ( ws, hs ) =
                    ( String.fromFloat wf, String.fromFloat hf )
            in
            g
                [ transform ("translate(" ++ xs ++ " " ++ ys ++ ")")
                ]
                [ but.renderBorder button
                , but.renderContent content button
                , but.renderOverlay wrapper button
                ]


{-| An attribute to disable mouse selection of an SVG element.

`renderContent` includes this.

From <https://www.webpagefx.com/blog/web-design/disable-text-selection/>. Thank you to Jacob Gube.

-}
disableSelection : Attribute msg
disableSelection =
    style <|
        -- Firefox
        "-moz-user-select: none;"
            -- Internet Explorer
            ++ "-ms-user-select: none;"
            -- KHTML browsers (e.g. Konqueror)
            ++ "-khtml-user-select: none;"
            -- Chrome, Safari, and Opera
            ++ "-webkit-user-select: none;"
            --  Disable Android and iOS callouts*
            ++ "-webkit-touch-callout: none;"
            -- Prevent resizing text to fit
            -- https://stackoverflow.com/questions/923782
            ++ "webkit-text-size-adjust: none;"


{-| Draw a button's transparent, mouse/touch-sensitive overlay.

This is the default overlay renderer for a button.

You won't usually use this, letting `render` call it for you.

You should call this AFTER drawing your button, so that the overlay is the last thing drawn. Otherwise, it may not get all the mouse/touch events.

-}
renderOverlay : (Msg -> msg) -> Button state msg -> Svg msg
renderOverlay wrapper (Button button) =
    let
        but =
            Button button

        ( w, h ) =
            button.size

        ws =
            String.fromFloat w

        hs =
            String.fromFloat h
    in
    Svg.rect
        [ x "0"
        , y "0"
        , width ws
        , height hs
        , opacity "0"
        , fillOpacity "1"
        , onTouchStart (\touch -> wrapper TouchStart)
        , onMouseDown (wrapper MouseDown)
        , onTouchEnd (\touch -> wrapper TouchEnd)
        , onMouseUp (wrapper MouseUp)
        , onMouseOut (wrapper MouseOut)
        , disableSelection
        ]
        []


{-| Draw a button's border.

This is the default border renderer for a button.

You won't usually use this, letting `render` call it for you.

You should call this BEFORE drawing your button, so that its opaque body does not cover your beautiful drawing.

-}
renderBorder : Button state msg -> Svg msg
renderBorder (Button button) =
    let
        ( w, h ) =
            button.size

        ws =
            String.fromFloat (w - 2)

        hs =
            String.fromFloat (h - 2)

        colors =
            button.colors
    in
    Svg.rect
        [ x "1"
        , y "1"
        , width ws
        , height hs
        , stroke colors.outline
        , fill colors.background
        , strokeWidth "2"
        , opacity "1"
        , strokeOpacity "1"
        ]
        []


{-| Render the visible, non-border part of a button.

This is the default content renderer for a button.

You won't usually use this, letting `render` call it for you.

But you could use it for a non-button, if you just want some text centered in a rectangle.

-}
renderContent : Content msg -> Button state msg -> Svg msg
renderContent content (Button button) =
    g [ disableSelection ]
        [ let
            ( xf, yf ) =
                button.size

            yfo2s =
                String.fromFloat (yf / 2)

            xfo2s =
                String.fromFloat (xf / 2)
          in
          case content of
            TextContent string ->
                text_
                    [ fill button.colors.text
                    , fontSize yfo2s
                    , x xfo2s
                    , y yfo2s
                    , textAnchor "middle"
                    , dominantBaseline "middle"
                    ]
                    [ text string ]

            SvgContent svg ->
                svg

            NoContent ->
                Svg.text ""
        ]


{-| The direction a triangular button points.
-}
type TriangularButtonDirection
    = UpButton
    | DownButton
    | RightButton
    | LeftButton


{-| Return the three corners of a triangular button.
-}
triangularButtonCorners : TriangularButtonDirection -> Button state msg -> ( Location, Location, Location )
triangularButtonCorners direction (Button button) =
    let
        ( w, h ) =
            button.size

        ho2 =
            (h - 2) / 2

        wo2 =
            (w - 2) / 2
    in
    case direction of
        UpButton ->
            ( ( 1, h ), ( wo2, 1 ), ( w, h ) )

        DownButton ->
            ( ( 1, 1 ), ( wo2, h ), ( w, 1 ) )

        LeftButton ->
            ( ( w, 1 ), ( 1, ho2 ), ( w, h ) )

        RightButton ->
            ( ( 1, 1 ), ( w, ho2 ), ( 1, h ) )


{-| Return a path string to draw a triangular button.
Suitable as the arg to `Svg.Attribute.d`.
-}
triangularButtonPathString : TriangularButtonDirection -> Button state msg -> String
triangularButtonPathString direction button =
    let
        ( ( x1, y1 ), ( x2, y2 ), ( x3, y3 ) ) =
            triangularButtonCorners direction button

        ( ( x1s, y1s ), ( x2s, y2s ), ( x3s, y3s ) ) =
            ( ( String.fromFloat x1, String.fromFloat y1 )
            , ( String.fromFloat x2, String.fromFloat y2 )
            , ( String.fromFloat x3, String.fromFloat y3 )
            )

        p x y =
            x ++ " " ++ y ++ " "
    in
    "M " ++ p x1s y1s ++ "L " ++ p x2s y2s ++ "L " ++ p x3s y3s ++ "Z"


{-| Draw a triangular button's overlay.

You'll usually use this via setTriangularButtonRenderers.

You should call this AFTER drawing your button, so that the overlay is the last thing drawn. Otherwise, it may not get all the mouse/touch events.

-}
renderTriangularOverlay : TriangularButtonDirection -> (Msg -> msg) -> Button state msg -> Svg msg
renderTriangularOverlay direction wrapper button =
    let
        pathString =
            triangularButtonPathString direction button
    in
    Svg.path
        [ opacity "0"
        , fillOpacity "1"
        , onTouchStart (\touch -> wrapper TouchStart)
        , onMouseDown (wrapper MouseDown)
        , onTouchEnd (\touch -> wrapper TouchEnd)
        , onMouseUp (wrapper MouseUp)
        , onMouseOut (wrapper MouseOut)
        , disableSelection
        , Svga.d pathString
        ]
        []


{-| Draw a triangular button's border.

You'll usually use this via setTriangularButtonRenderers.

You should call this BEFORE drawing your button, so that its opaque body does not cover your beautiful drawing.

-}
renderTriangularBorder : TriangularButtonDirection -> Button state msg -> Svg msg
renderTriangularBorder direction button =
    case button of
        Button but ->
            let
                pathString =
                    triangularButtonPathString direction button

                colors =
                    but.colors
            in
            Svg.path
                [ stroke colors.outline
                , fill colors.background
                , strokeWidth "2"
                , opacity "1"
                , strokeOpacity "1"
                , Svga.d pathString
                ]
                []


{-| Change the button to render as a triangle, instead of a rectangle.
-}
setTriangularButtonRenderers : TriangularButtonDirection -> Button state msg -> Button state msg
setTriangularButtonRenderers direction (Button button) =
    Button
        { button
            | renderBorder = renderTriangularBorder direction
            , renderOverlay = renderTriangularOverlay direction
        }



---
--- From https://github.com/knledg/touch-events/blob/master/src/TouchEvents.elm
--- Copied, so I don't have to wait for that project to upgrade.
---


{-| event decoder
-}
eventDecoder : (Touch -> msg) -> String -> JD.Decoder msg
eventDecoder msg eventKey =
    JD.at [ eventKey, "0" ] (JD.map msg touchDecoder)


{-| touch decoder
-}
touchDecoder : JD.Decoder Touch
touchDecoder =
    map2 Touch
        (field "clientX" float)
        (field "clientY" float)


{-| Type alias for the touch record on the touch event object
-}
type alias Touch =
    { clientX : Float
    , clientY : Float
    }


{-| Lower level "touchend" event handler
Takes the application `Msg` type which should take `TouchEvents.Touch`
as a payload

    type Msg
        = UserSwipeEnd TouchEvents.Touch

    view model =
        div
            [ TouchEvents.onTouchEnd UserSwipeEnd
            ]
            []

-}
onTouchEnd : (Touch -> msg) -> Html.Attribute msg
onTouchEnd msg =
    on "touchend" <| eventDecoder msg "changedTouches"


{-| Lower level "touchstart" event handler
Takes the application `Msg` type which should take `TouchEvents.Touch`
as a payload

    type Msg
        = UserSwipeStart TouchEvents.Touch

    view model =
        div
            [ TouchEvents.onTouchStart UserSwipeStart
            ]
            []

-}
onTouchStart : (Touch -> msg) -> Html.Attribute msg
onTouchStart msg =
    on "touchstart" <| eventDecoder msg "touches"


{-| Lower level "touchmove" event handler
-}
onTouchMove : (Touch -> msg) -> Html.Attribute msg
onTouchMove msg =
    on "touchmove" <| eventDecoder msg "touches"
